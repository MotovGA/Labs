:imagesdir: Images
:figure-caption: Рисунок

== Лабораторная работа №0
=== Задание
Создать проект  *Lab1* под микроконтроллер *STM32F411RE* в IDE *IAR Embedded Workbench*, затем написать код программы, которая считает сумму двух *char* чисел (например *4* и *254*) или (*4* и *-6*).

=== Создадим проект в IAR Workbench
* Создадим новый проект Project => Create New Project (рисунок 1).

.Создание нового проекта
image::img1.png[]

=== Код программы
Напишем код программы, которая считает сумму двух *char* чисел (*4* и *254*). Код программы, представленный на рисунке 2, код будет записан в функцию main - функцию, с которой начинается программа.

.Код программы
image::img2.png[]

=== Запуск программы в режиме отладки

После того, как проект сделан, и имеет вид показанный на рисунке 3, можно попробовать собрать проект, нажав кнопку *Ctrl+F7*, а затем загрузить файл в микропроцессор и запустить на отладку с помощью кнопки *Ctrl+D*.

Все тоже самое можно сделать и с помощью кнопок быстрого доступа на панели инструментов.

.Вид созданного проекта
image::img3.png[]

Нажатием на кнопку *F9* мы зададим точку остановки. Точки остановки нужны для того, чтобы проверить код на правильность написания. В режиме отладки можно переключать каждый шаг программы с помощью кнопок *F10*, *F11*.

=== Вывод результата в Terminal I/O
*Terminal I/O* - это консоль, в которой можно наблюдать за результатом вывода программы. Для отображения окна Terminal I/O необходимо запустить код в режиме отладки и затем в окне *View* выбрать *Terminal I/O*.

Запустим код в режиме отладки и проверим результат нашей программы в окне *Terminal I/O* (рисунок 4). При нажатии на *F5* произойдет выполнение программы.

.Вывод результатов в окне Terminal I/O
image::img4.png[]
.Вывод результатов в окне Terminal I/O при отрицательных значениях
image::img4,2.png[]

Полученные результаты объясняются тем, что переменная *char* - 8-битное число, то есть ее вместимость 256 символов от 0 до 255. При сложении 4 + 254 получаем число равное 2. При суммировании чисел сумма которых превышает 255 произошло переполнение переменной и всё началось сначала. То есть после 255 произошло переполнение и оставшиеся 3 значения перешли в начало отсчёта. При сложении 4 + (-6) получаем число равное -2, но в переменной char такого числа нет и она уменьшается с конца, то есть мы получаем число 254. То есть 4-6=-2 и при -1 мы бы получили 0, а при -2 отсчёт начался сначала. И получилось 255-1=254

=== Окна Watch и Registers
Для того, чтобы просмотреть как изменяются переменные на пути всего когда можно использовать окно *Watch*, которое можно открыть в режиме отладки во вкладке *View*. С помощью клавиш *F10* или *F11* можно идти по коду и наблюдать изменение значений переменных в окне Watch.

В окне *Registers* можно просматривать значения регистров в которых созданы переменные (при условии, что они там созданы). Чтобы это окно нужно нажать в режиме отладки во вкладке *View* на строчку *Registers* (рисунок 6).

.Просмотр регистров в окне Registers и переменных в окне Watch
image::img5.png[]

Аналогично окну *Watch* можно просматривать изменение регистров пройдясь по коду клавишами *F10* или *F11*.

====
*Ответы на вопросы первого раздела*

[qanda]
*1.* Дайте определение понятию “Интегрированной среде разработки”
----
Ответ:
Интегрированная среда разработки (IDE) - система программных средств, используемая программистами для разработки программного обеспечения.

  Включает в себя:
⦁ текстовый редактор;
⦁ компилятор;
⦁ средства автоматизации сборки;
⦁ отладчик.
----
*2.* Что такое компилятор и чем он отличается от транслятора?
----
Ответ:
 Компилятор - программа выполняющая трансляцию исходного кода из предметно-ориентированногоязыка на мишинно-ориентированный язык.
 Транслятор - это программа-переводчик. Она преобразует программу, написанную на одном из языков высокого уровня, в программу, состоящую из машинных команд.
 Компилятор отличается от транслятора лишь тем, что его результирующая программа всегда должна быть написана на языке машинных кодов или на языке ассемблера.
----
*3.* Что такое компоновщик и какие функции он выполняет?
----
Ответ:
 Компоновщик (Линковщик) - программа собриющая исходный код на машино-ориентированном языке и производящая сборку в исполняемый модуль.
----
*4.* Почему важен процесс проектирования ПО какие задачи входят в этот процесс?
----
Ответ: процесс проектирования ПО важен потому, что при его создании происходит упорядочевание действий, а без порядка проектирования возможны ошибки при создании. Ошибки могут повлечь увеличение стоимости разработки.
 Процесс проектирования ПО включает следующие задачи:
⦁ выбор метода и стратегии решения;
⦁ выбор представления внутренних данных;
⦁ разработка основного алгоритма;
⦁ документирование ПО;
⦁ тестирование и подбор тестов;
⦁ выбор представления входных данных.
----
*5.* Дорисуйте процесс разработки ПО, описанный на изображении *IAR_Workbench* с учетом итеративности связей в этом процессе
-----
Ответ:
-----

image::A1.png[]

*6.* Зачем нужна отладка и в каких случаях она применяется? Для чего применяются точки остановки?
----
Ответ: отладка нужна для поиска различных ошибок и багов в коде. И для просмотра значений конкретных переменных в нужный момент времени т.д.
 Типичным примером является, необходимость исключить ошибку в большом коде. Для нахождения места ошибки применяют точки остановки. На полях ставят эту точку нажатием ЛКМ по полю напротив той строчки с которой могла начатся ошибка и запускают код в режиме отладки.
----
*7.* Какие еще важные характеристики IAR Workbench можно добавить в таблицу *Характеристики IAR*
----
Ответ: контроль регистров.
----
